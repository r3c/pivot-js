<html>
	<head>
		<meta charset="utf-8" />
		<style type="text/css">
			/* Page styles */
			body {
				display: flex;
				flex-direction: column;
				align-items: stretch;
				height: 100%;
				box-sizing: border-box;
				padding: 16px;
				margin: 0;
				font: 16px serif;
			}

			.control {
				padding: 0 0 8px 0;
			}

			/* Pivot table styles */
			.pivotGrid {
				position: relative;
			}

			.pivotGrid>div {
				position: absolute;
				box-sizing: border-box;
				border-left: 1px solid grey;
				border-top: 1px solid grey;
			}

			.pivotView {
				flex: 1;
				overflow: scroll;
				border: 1px solid black;
			}

			/* Custom cell styles */
			.cell {
				display: flex;
				flex-direction: column;
				height: 100%;
				overflow: hidden;
			}

			.cell:hover {
				background: rgb(255, 248, 215);
			}

			.cell-boolean>input {
				flex: 1;
			}

			.cell-dimension>span {
				flex: 1;
				display: flex;
				align-items: center;
				align-self: flex-end;
				padding: 4px 8px;
				margin: 4px;
				font-size: 80%;
				border-radius: 6rem;
				background-color: rgb(200, 206, 237);
				color: rgb(37, 44, 137);
			}

			.cell-plain>input {
				flex: 1;
				padding: 2px 4px;
				margin: 4px;
			}

			.cell-plain>span {
				flex: 1;
				display: flex;
				align-items: center;
				justify-content: end;
				padding: 0 4px;
			}
		</style>
	</head>
	<body>
		<div class="control">
			Initialize a pivot table of
			<input id="nbColumns" type="number" value="40" min="0" max="100" /> columns by
			<input id="nbRows" type="number" value="1000" min="0" max="10000" /> rows
			<input id="initialize" type="button" value="Go" />
		</div>
		<div id="pivotView" class="pivotView">
			<div id="pivotGrid" class="pivotGrid"></div>
		</div>
		<script type="text/javascript">
			(function () {
				// Cell rendering functions by type
				function createBooleanValue(value, update) {
					let checkbox = document.createElement('input');

					checkbox.addEventListener('change', (e) => {
						value = checkbox.checked;

						update(value)
					});
					checkbox.checked = value;
					checkbox.type = 'checkbox';

					let container = document.createElement('div');

					container.appendChild(checkbox);
					container.className = 'cell cell-boolean';

					return container;
				}

				function createDimensionValue(value, update) {
					let chip = document.createElement('span');

					chip.innerText = value;

					let container = document.createElement('div');

					container.appendChild(chip);
					container.className = 'cell cell-dimension';

					return container;
				}

				function createPlainValue(value, update) {
					let container = document.createElement('div');

					container.className = 'cell cell-plain';

					function createDisplay() {
						let element = document.createElement('span');

						element.innerText = value;
						element.addEventListener('dblclick', () => replaceWith(createInput()));

						return element;
					}

					function createInput() {
						let element = document.createElement('input');

						element.value = value;
						element.addEventListener('keyup', (e) => {
							if (e.key === 'Enter' || e.key === 'Escape') {
								if (e.key === 'Enter') {
									value = element.value;

									update(value);
								}

								replaceWith(createDisplay());

								return false;
							}
						});

						return element;
					}

					function replaceWith(element) {
						if (container.firstElementChild) {
							container.removeChild(container.firstElementChild);
						}

						container.appendChild(element);
					}

					replaceWith(createDisplay());

					return container;
				}

				// Basic quad tree implementation
				function quadTreeBalance(node) {
					return node; // FIXME: not implemented
				}

				function quadTreeInsert(node, x, y, value) {
					if (node === undefined) {
						return {
							ne: undefined,
							nw: undefined,
							se: undefined,
							sw: undefined,
							value: value,
							x: x,
							y: y
						};
					}

					if (x < node.x) {
						if (y < node.y) {
							node.nw = quadTreeInsert(node.nw, x, y, value);
						} else {
							node.sw = quadTreeInsert(node.sw, x, y, value);
						}
					}
					else {
						if (y < node.y) {
							node.ne = quadTreeInsert(node.ne, x, y, value);
						} else {
							node.se = quadTreeInsert(node.se, x, y, value);
						}
					}

					return node;
				}

				function quadTreeSearch(node, x, y) {
					if (node === undefined) {
						return undefined;
					}

					if (x < node.x) {
						if (y < node.y) {
							return quadTreeSearch(node.nw, x, y);
						} else {
							return quadTreeSearch(node.sw, x, y);
						}
					}
					else {
						if (y < node.y) {
							return quadTreeSearch(node.ne, x, y);
						} else {
							return quadTreeSearch(node.se, x, y) || node;
						}
					}
				}

				// Pivot table definition
				function pivotCreate(view, grid, table) {
					// Initialize quad tree with pivot positions
					let iStop = table.pivot1.length;
					let jStop = table.pivot2.length;
					let root = undefined;
					let y = 0;

					for (let j = 0; j < jStop; ++j) {
						let x = 0;

						for (let i = 0; i < iStop; ++i) {
							root = quadTreeInsert(root, x, y, [i, j]);

							x += table.pivot1[i].width;
						}

						y += table.pivot2[j].height;
					}

					root = quadTreeBalance(root);

					// Clear and resize grid
					for (let child = grid.lastElementChild; child; child = grid.lastElementChild) {
						grid.removeChild(child);
					}

					grid.style.width = table.pivot1.reduce((a, p) => a + p.width, 0);
					grid.style.height = table.pivot2.reduce((a, p) => a + p.height, 0);

					// Create cache and run first rendering
					let cache = pivotRender(view, grid, table, root, {});

					return () => cache = pivotRender(view, grid, table, root, cache);
				}

				function pivotRender(view, grid, table, root, cellCache) {
					let node = quadTreeSearch(root, view.scrollLeft, view.scrollTop);

					if (node === undefined) {
						return;
					}

					let cellCacheNext = {};
					let data = table.data;
					let iStart = node.value[0];
					let iStop = table.pivot1.length;
					let jStart = node.value[1];
					let jStop = table.pivot2.length;
					let xStart = node.x;
					let xStop = view.scrollLeft + view.clientWidth;
					let yStart = node.y;
					let yStop = view.scrollTop + view.clientHeight;

					for (let j = jStart, y = yStart; j < jStop && y < yStop; y += table.pivot2[j].height, j += 1) {
						for (let i = iStart, x = xStart; i < iStop && x < xStop; x += table.pivot1[i].width, i += 1) {
							let index = i + j * iStop;
							let value = data[index].value;
							let cell;

							if (cellCache[index]) {
								cell = cellCache[index];

								delete cellCache[index];
							}
							else {
								cell = document.createElement('div')
								cell.appendChild(data[index].constructor(value, (v) => data[index].value = v));
								cell.style.left = x;
								cell.style.top = y;
								cell.style.height = table.pivot2[j].height + 'px';
								cell.style.width = table.pivot1[i].width + 'px';
							}

							cellCacheNext[index] = cell;

							grid.appendChild(cell);
						}
					}

					// Remove stale elements from cache and return updated one
					for (let index in cellCache) {
						grid.removeChild(cellCache[index]);
					}

					return cellCacheNext;
				}

				// Initialize pivot table and attach event listeners
				let properties = Object.entries(window).map(e => e[0]);

				function createArray(length, generator) {
					return new Array(length).fill(undefined).map((_, index) => generator(index));
				}

				function createCell(columnIndex) {
					switch (columnIndex % 4) {
						case 2:
							return { constructor: createDimensionValue, value: properties[Math.floor(Math.random() * properties.length)] };

						case 3:
							return { constructor: createBooleanValue, value: Math.random() < 0.5 };

						default:
							return { constructor: createPlainValue, value: Math.floor(Math.random() * 100) };
					}
				}

				function createTable() {
					let nbColumns = Math.max(Math.min(document.getElementById('nbColumns').value, 100), 0);
					let nbRows = Math.max(Math.min(document.getElementById('nbRows').value, 10000), 0);

					if (nbColumns * nbRows > 100000 && !confirm('Generating data is going to take a while and hang your browser for a few minutes, are you sure?')) {
						return { pivot1: [], pivot2: [], data: [] };
					}

					return {
						pivot1: createArray(nbColumns, (index) => ({ label: 'Country #' + index, width: 60 + ~~(Math.random() * 120) })),
						pivot2: createArray(nbRows, (index) => ({ label: 'Product #' + index, height: 34 })),
						data: createArray(nbColumns * nbRows, (index) => createCell(index % nbRows))
					};
				}

				// Attach initialization function to button
				let pivotGrid = document.getElementById('pivotGrid');
				let pivotView = document.getElementById('pivotView');
				let render = pivotCreate(pivotView, pivotGrid, createTable());

				document.getElementById('initialize').addEventListener('click', () => render = pivotCreate(pivotView, pivotGrid, createTable()));
				pivotView.addEventListener('scroll', () => render());
				window.addEventListener('resize', () => render());
			})();
		</script>
	</body>
</html>